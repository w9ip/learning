Глобальная Блокировка Интерпретатора (GIL) - представляет собой [мьютекс](#мьютекс), который позволяет только одному [потоку](#потоки) удерживать управление интерпретатором Python.

Другими словами, в CPython из-за GIL, только один поток может находиться в состоянии выполнения.

Влияние GIL незаметно, когда мы разрабатываем однопоточные программы, однако, если мы хотим достичь *оптимизацию*, засчет параллельного программирования, то мы столкнемся с трудностями из-за GIL.

Какую проблему решает GIL?

В Python для управления памятью используется подсчет ссылок. Это означает, что объекты, созданные в Python, имеют переменную подсчета ссылок (reference count), которая отслеживает количество ссылок, указывающих на объект. Когда этот счетчик достигает нуля, память, занимаемая объектом, освобождается.
Для демонстрации работы подсчета ссылок рассмотрим небольшой пример кода:
```pycon
>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3
```
В приведенном примере количество ссылок на объект пустого списка [] равно 3. На объект списка ссылались a, b и аргумент, переданный в sys.getrefcount().

Проблема здесь заключается в том, что переменная подсчета ссылок нуждается в защите от *состояния гонки* (race condition). Состояние гонки, это когда два потока пытаются увеличить/уменьшить

## memory management
...

## потоки
В рамках ОС, поток - это сущность операционной системы, процесс выполнения набора инструкций на процессоре, точнее говоря программного кода. Общее назначение потоков - параллельное выполнение двух или более различных задач. Потоки были первым шагом на пути к многозадачности ОС. Планировщик ОС, руководствуясь приоритетом потока, распределяет кванты времени между разными потоками и ставит потоки на выполнение. На ряду с потоком, в рамках ОС, существует также такая сущность как процесс. Процесс - не что более иное, как некая абстракция, которая инкапсулирует в себе все ресурсы процесса (открытые файлы, файлы отображенные в памяти...) и их дескрипторы, потоки и т.д. Каждый процесс имеет как минимум один поток. Также каждый процесс имеет свое собственное виртуальное адресное пространство и контекст выполнения, а потоки одного процесса разделяют адресное пространство процесса. 

Каждый поток, как и каждый процесс имеет свой контекст. Контекст это структура, в которой сохраняются следующие элементы:
- Регистры процессора
- Указатель на стек потока/процесса.

В общем случае справедливы следующие рекомендация:
- Если ваша задача требует интенсивного распараллеливания, используйте потоки одного процесса, вместо нескольких процессов. Все потому, что переключение контекста процесса происходит гораздо медленнее, чем контекста потока.
- При использовании потока, старайтесь не злоупотреблять средствами синхронизации, которые требуют системных вызовов ядра (например мьютексы). Переключение в редим ядра — дорогостоящая операция!
- Если вы пишете код, исполняемый в ring0 (к примеру драйвер), старайтесь обойтись без использования дополнительных потоков, так как смена контекста потока — дорогостоящая операция.

## однопоточные программы
...

## мьютекс
Мьютекс подобен ключу от туалета на заправочной станции, гарантирующему, что только один человек может пользоваться туалетом одновременно, и никто другой не может пользоваться туалетом, пока текущий посетитель не закончит и ключ не будет возвращен.

## Системный вызов
Системный вызов - это механизм взаимодействия пользовательских программ с ядром Linux. Есть мощный инструмент для их отслеживания - `strace`. Для понимания работы ОС полезно разобратьсяс тем, как работают системные вызовы.

В ОС, можно выделить 2 режима работы:

1. Режим ядра (kernel mode) - привилегированный режим, используемый ядром ОС.
2. Пользовательский режим (user mode) - режим, в котором выполняется большинство пользовательских приложений.

Когда пользоваетель ОС использует утилиты командной строки или графический интерфейс, на фоне неявно работают системные вызовы, обращаясь к ядру для выполнения работы.

Системные вызовы похожи на обычные функции, тем, что в них можно передавать аргументы и эти функции что-то возвращают. Единственные отличие состоит в том, что системные вызовы работают на уровне ядра. Переключение из пользовательского режима в режим ядра осуществляется с помощью [прерываний](https://en.wikipedia.org/wiki/Trap_(computing)).


