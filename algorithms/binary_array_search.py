def binary_array_search(A, target):
    # Поначалу lo и hi равны наименьшему и наибольшему индексу в А.
    lo = 0  # Наименьший индекс в А.
    hi = len(A) - 1  # Наибольший индекс в А.
    
    # Цикл закончится, когда диапазон поиска опустеет.
    while lo <= hi:
        
        # В диапазоне A[lo ... hi] найдем середину и значение A[mid] в ней.
        mid = (lo + hi) // 2
        
        # Оптимизация, которая требует только одного сравнения элементов списка.
        diff = target - A[mid]
        if diff < 0:
            hi = mid - 1
        elif diff > 0:
            lo = mid + 1
        else:
            return mid
        
        
        
#         # Если target меньше A[mid], продолжим поиск 'слева' от середины.
#         if target < A[mid]:
#             # Если это так, сужаем диапазон поиска до левой части A[lo ... mid-1]
#             hi = mid-1
#             
#         # Если target больше A[mid], продолжим поиск 'справа' от середины.   
#         elif target > A[mid]:
#             # Если это так, сужаем диапазон поиска до правой части A[lo ... mid+1]
#             lo = mid+1
#             
#         else:
#             return mid  # Возвращаем mid, потому-что именно здесь мы нашли target.


    
    # Если target существует в А, вернется его индекс (положительное число).
    # Если его не существует, то вернется индекс (отрицательное число),
    # куда можно будет вставить отсутствующий элемент не нарущая порядок А.
    return -(lo+1)
    # Таким образом мы вычислим место, куда его следует при необходимости вставить,
    # Не нарушая порядок A.
    
    
    
print(binary_array_search([3, 14, 15, 18, 26, 53, 58], 53))