def tournament_two(A):
    N = len(A)
    winner = [None] * (N-1)  # В этих списках мы станем хранить индексы победтелей 
    loser = [None] * (N-1)   # и проигравших в игре, которых будет N-1.
    prior = [-1] * (N-1)  # Когда значение в позиции m проходит на очередной тур,
    # в prior[m] записывается позиция этого значения в предыдущем туре. Для первого
    # тура такой информации нет, поэтому в начале этого списка хранится -1.
    idx = 0
    for i in range(0, N, 2):  # Первый тур состит из N/2 игр, то есть требуется N/2
        if A[i] < A[i+1]:     # сравнений на 'меньше' в парах "победитель-проигравший"
            winner[idx] = A[i+1]
            loser[idx] = A[i]
        else:
            winner[idx] = A[i]
            loser[idx] = A[i+1]
        idx += 1
        
    m = 0  # Игры победителей во всех следующих турах с записью позиции проигравшего в каждой игре.
    while idx < N-1:  # Еще N/2-1 сравнение.
        if winner[m] < winner[m+1]:
            winner[idx] = winner[m+1]
            loser[idx] = winner[m]
            prior[idx] = m+1
        else:
            winner[idx] = winner[m]
            loser[idx] = winner[m+1]
            prior[idx] = m
        m += 2        # Увеличим m на 2 - это игра двух следующих победителей. Когда idx достигнет N-1,
        idx += 1      # в winner[m] окажется наибольшее значение.
    
    largest = winner[m]
    second = loser[m]  # Первый кондидат на второе место, надо еще проверить остальных проигравших
    m = prior[m]       # чемпиону, возможно, они больше подходят для второго места.
    while m >= 0:
        if second < loser[m]:  # Не больше log(N)-1 дополнительное сравнение на "меньше".
            second = loser[m]
        m = prior[m]
    
    return (largest, second)


print(tournament_two([3, 1, 4, 1, 5, 9, 2, 6]))